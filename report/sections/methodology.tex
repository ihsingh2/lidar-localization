\section{Methodology}
\label{sec:methodology}

\subsection{Problem Formulation}
The global localization problem is formulated as determining the 6-DoF (Degrees of Freedom) pose of a LiDAR sensor within a pre-built 3D map. Let the pose be represented by the transformation vector $\mathbf{x} = [x, y, z, \alpha, \beta, \gamma]^T$, where $(x, y, z)$ denote the translational components and $(\alpha, \beta, \gamma)$ represent the rotational components corresponding to roll, pitch, and yaw angles, respectively. The objective is to find the optimal pose $\mathbf{x}^*$ that maximizes the matching score between the incoming LiDAR scan $\mathcal{S} = \{\mathbf{s}_k \in \mathbb{R}^3 \mid k = 1, \dots, K\}$ and the pre-built map $\mathcal{M} = \{\mathbf{m}_n \in \mathbb{R}^3 \mid n = 1, \dots, N\}$.

Mathematically, the problem can be expressed as:

$$\mathbf{x}^* = \arg\max_{\mathbf{x} \in \mathcal{X}} \sum_{k=1}^{K} \mathcal{M}(T_{\mathbf{x}}\mathbf{s}_k)$$

where $T_{\mathbf{x}}$ is the transformation matrix corresponding to pose $\mathbf{x}$, and $\mathcal{M}(\cdot)$ denotes the occupancy function of the map $\mathcal{M}$ at a given point.

To further elaborate, the transformation matrix $T_{\mathbf{x}}$ is defined as:

\begin{equation*}
T_{\mathbf{x}} = \begin{bmatrix}
R(\alpha, \beta, \gamma) & \mathbf{t} \\
\mathbf{0}^T & 1
\end{bmatrix},
\end{equation*}

where $R(\alpha, \beta, \gamma)$ is the rotation matrix parameterized by Euler angles $(\alpha, \beta, \gamma)$, and $\mathbf{t} = [x, y, z]^T$ is the translation vector.

\subsection{3D Branch-and-Bound Scan Matching (3D-BBS)}
The proposed 3D-BBS algorithm extends the 2D BBS framework to three dimensions, enabling efficient global localization in 3D environments. The algorithm leverages a multi-resolution voxel map and employs a batched BnB strategy accelerated by GPU parallel processing.

\subsubsection{Multi-resolution Voxel Map}
To manage memory consumption effectively, a multi-resolution voxel map is utilized, where the voxel size at each hierarchical level $l$ is defined as $r_l = 2^l r$, with $r$ being the minimum voxel size. The voxel grid is represented using a sparse hash table to store only occupied voxels, significantly reducing memory usage compared to dense voxel grids.

The occupancy function $\mathcal{H}_l(\mathbf{v})$ at level $l$ for voxel $\mathbf{v} = [v_x, v_y, v_z]^T$ is defined as:

\begin{equation*}
\mathcal{H}_l(\mathbf{v}) = 
\begin{cases}
1 & \text{if voxel } \mathbf{v} \text{ is occupied}, \\
0 & \text{otherwise}.
\end{cases}
\end{equation*}

A spatial hashing function is employed to map voxel coordinates to hash buckets:

$$\text{hash}(\mathbf{v}) = f(\mathbf{v}) \mod T_l$$

where $f(\mathbf{v})$ computes a unique hash value for voxel $\mathbf{v}$, and $T_l$ is the size of the hash table at level $l$. To handle hash collisions, open addressing with linear probing is implemented, ensuring that each voxel is uniquely mapped to a hash bucket without significant performance degradation.

The hierarchical voxel map allows the algorithm to efficiently compute upper bounds on matching scores by aggregating occupancy information across different resolutions. This multi-scale representation is crucial for balancing computational efficiency with localization accuracy.

\subsubsection{Branching Strategy}
The pose search space is hierarchically partitioned using the BnB algorithm. At each node in the search tree, an upper bound on the possible matching score is computed. If this upper bound is lower than the current best score, the node and its descendants are pruned from the search space.

In 3D-BBS, the search space includes both translational and rotational components. The branching process involves subdividing the pose space into finer partitions at each hierarchical level. The rotational branching is designed to handle the increased dimensionality effectively.

The branching strategy is defined as follows:

1. \textbf{Translational Branching}: At each level $l$, the translational search space is divided into $2^3 = 8$ subspaces along the $x$, $y$, and $z$ axes. Each child node represents a subspace with a reduced voxel size $r_{l-1} = r_l / 2$.

2. \textbf{Rotational Branching}: The rotational components $(\alpha, \beta, \gamma)$ are similarly partitioned. The yaw angle $\gamma$ is divided into smaller increments $\delta_l$ at each level to ensure finer rotational resolution.

Mathematically, for a parent node $c = (c_x, c_y, c_z, c_\alpha, c_\beta, c_\gamma, l)$, the children nodes are generated by:

$C_{c,l} = \{(2c_x + j_x, 2c_y + j_y, 2c_z + j_z, c_\alpha + k_\alpha \delta_l, c_\beta + k_\beta \delta_l, c_\gamma + k_\gamma \delta_l, l-1) \mid j_x, j_y, j_z \in \{0,1\}, k_\alpha, k_\beta, k_\gamma \in \mathbb{Z}\}$,

where $j_x, j_y, j_z$ denote the subspace indices along the translational axes, and $k_\alpha, k_\beta, k_\gamma$ denote the subdivision indices for the rotational angles.

\subsubsection{Score Calculation}
The matching score for a given pose $\mathbf{x}$ is calculated as the sum of occupancy values of the transformed scan points:
$$\text{score}(\mathbf{x}) = \sum_{k=1}^{K} \mathcal{H}_l(T_{\mathbf{x}}\mathbf{s}_k)$$
To compute the upper bound efficiently, precomputed occupancy maps at each hierarchical level are utilized. The upper bound for a parent node is estimated by aggregating the maximum possible contributions from its child nodes:
$$\text{score}_{\text{upper}}(c) = \sum_{k=1}^{K} \max_{\mathbf{v} \in \mathcal{N}(T_{\mathbf{x}_c} \mathbf{s}_k)} \mathcal{H}_l(\mathbf{v})$$
where $\mathcal{N}(\cdot)$ denotes the neighborhood voxels surrounding the transformed scan point $T_{\mathbf{x}}c \mathbf{s}_k$. This estimation ensures that the upper bound remains valid while facilitating effective pruning.

\subsubsection{Batched BnB Algorithm}
To enhance computational efficiency, especially given the parallel processing capabilities of GPUs, a batched approach to the BnB algorithm is adopted. Multiple nodes are processed simultaneously, leveraging GPU parallelism to compute scores and perform branching operations.

The batched BnB algorithm operates as follows:

\begin{algorithm}[h]
\caption{3D Branch-and-Bound Scan Matching (3D-BBS)}
\label{alg:3dbbs}
\begin{algorithmic}[1]
\STATE \textbf{Input:} LiDAR scan $\mathcal{S}$, map $\mathcal{M}$, parameters $l_{\text{max}}$, $r$, $b$, score threshold
\STATE \textbf{Output:} Best pose $\mathbf{x}^*$
\STATE Precompute multi-resolution voxel maps $\mathcal{H}_l$ for $l = 0$ to $l_{\text{max}}$
\STATE Initialize best score $\leftarrow$ score threshold
\STATE Initialize queue $C$ with initial pose candidates at $l_{\text{max}}$
\WHILE{$C$ is not empty}
    \STATE Pop a batch of $b$ nodes from $C$
    \STATE Transfer batch to GPU memory
    \STATE Compute scores for all nodes in the batch on GPU
    \FOR{each node $c$ in the batch}
        \IF{$\text{score}(c) > \text{best score}$}
            \IF{$c$ is a leaf node at $l=0$}
                \STATE Update best score $\leftarrow$ \text{score}(c)
                \STATE Update best match $\leftarrow$ $c$
            \ELSE
                \STATE Branch $c$ into children $C_{c,l-1}$
                \STATE Add children $C_{c,l-1}$ to CPU queue $C$
            \ENDIF
        \ENDIF
    \ENDFOR
    \STATE Sort updated queue $C$ by descending score
\ENDWHILE
\STATE \textbf{return} best match $\mathbf{x}^*$
\end{algorithmic}
\end{algorithm}

This batched approach minimizes the overhead associated with CPU-GPU data transfers by processing large groups of nodes in parallel. The algorithm ensures that the most promising nodes are evaluated first, maximizing the effectiveness of pruning and reducing overall computation time.

\subsection{Integration with KISS-ICP}
KISS-ICP (Keep It Simple and Straightforward Iterative Closest Point) is employed as a preliminary step to generate accurate 3D LiDAR maps. KISS-ICP performs local fine registration between consecutive LiDAR scans, refining the alignment and reducing the drift inherent in sequential scan matching.

The integration process involves the following steps:

1. \textbf{Map Generation}: Utilize KISS-ICP to align and merge sequential LiDAR scans, constructing a coherent and accurate 3D point cloud map $\mathcal{M}$.

2. \textbf{Initial Alignment}: Provide an initial rough alignment of incoming LiDAR scans based on KISS-ICP's output, facilitating the subsequent global localization process.

3. \textbf{Feedback Loop}: Incorporate feedback from the global localization results to further refine the map, ensuring consistency and accuracy over time.

Mathematically, KISS-ICP minimizes the following objective function to estimate the relative transformation between consecutive scans:

$$\mathbf{x}_{\text{ICP}}^* = \arg\min_{\mathbf{x}} \sum_{k=1}^{K} \|\mathbf{m}_k - T_{\mathbf{x}}\mathbf{s}_k\|^2$$

where $\mathbf{m}_k$ are the nearest neighbors in the map $\mathcal{M}$ corresponding to scan points $\mathbf{s}_k$. This optimization ensures that the scan points are aligned as closely as possible with the map, providing a solid foundation for the global localization process.

\subsection{Parameter Ablation Studies}
Ablation studies are essential to understand the influence of various configuration parameters on the performance of the 3D-BBS algorithm. By systematically varying each parameter and observing the resultant changes in localization accuracy and processing time, optimal settings can be identified.

The parameters under investigation include:

\begin{itemize}
    \item \textbf{max\_level}: Determines the depth of the hierarchical search. Higher levels correspond to finer subdivisions, allowing for more precise localization but increasing computational complexity.
    \item \textbf{max\_scan\_range}: Specifies the maximum range of LiDAR scans considered. A larger range encompasses more environmental features but may introduce noise and outliers.
    \item \textbf{min\_level\_res}: Defines the minimum resolution at the finest hierarchical level. Lower resolutions enhance localization precision but require more computational resources.
    \item \textbf{src\_leaf\_size} and \textbf{tar\_leaf\_size}: Control the voxel grid filtering for source and target point clouds, respectively. Smaller leaf sizes preserve more detail but increase the number of voxels, impacting both memory usage and processing time.
\end{itemize}

\subsubsection{Effect of max\_level}
The \textit{max\_level} parameter controls the hierarchical depth of the voxel map. Increasing \textit{max\_level} allows the algorithm to explore finer pose subdivisions, enhancing localization accuracy. However, this comes at the cost of increased computational overhead due to the exponential growth in the number of candidate poses.

To quantify this trade-off, we conducted experiments varying \textit{max\_level} from 4 to 8. The results indicate that beyond a certain level (e.g., $l_{\text{max}} = 6$), the improvement in localization accuracy diminishes while processing time continues to rise significantly. Therefore, an optimal balance is achieved at $l_{\text{max}} = 6$, providing sufficient pose resolution without incurring prohibitive computational costs.

\subsubsection{Effect of max\_scan\_range}
The \textit{max\_scan\_range} parameter defines the extent of the LiDAR scan utilized for localization. A larger scan range increases the number of points contributing to the matching score, potentially improving robustness against partial occlusions and sparse environments. However, it also introduces more noise and outliers, which can adversely affect localization accuracy.

Experiments were performed with \textit{max\_scan\_range} set to 30m, 50m, and 70m. The findings suggest that increasing the scan range up to 50m yields noticeable improvements in localization accuracy, particularly in urban environments with ample structural features. Beyond 50m, the marginal gains are outweighed by the increased computational load and the presence of more outliers, leading to a slight decrease in performance.

\subsubsection{Effect of min\_level\_res}
The \textit{min\_level\_res} parameter dictates the voxel resolution at the finest hierarchical level. Lower resolutions (smaller voxel sizes) allow for more precise localization by capturing finer details of the environment. However, this also results in a larger number of voxels, increasing both memory usage and computation time.

We evaluated \textit{min\_level\_res} values of 0.1m, 0.2m, and 0.5m. The results demonstrate that a resolution of 0.2m strikes an optimal balance, providing adequate detail for accurate localization while maintaining reasonable computational efficiency. Resolutions finer than 0.2m offer negligible improvements in accuracy but significantly inflate processing times.

\subsubsection{Effect of src\_leaf\_size and tar\_leaf\_size}
The leaf sizes for source and target point clouds, \textit{src\_leaf\_size} and \textit{tar\_leaf\_size}, determine the level of downsampling applied to the point clouds. Smaller leaf sizes preserve more geometric details, enhancing the fidelity of the matching process. Conversely, larger leaf sizes reduce the number of points, thereby decreasing computational demands but potentially losing critical information necessary for accurate localization.

Ablation experiments were conducted with \textit{src\_leaf\_size} and \textit{tar\_leaf\_size} set to 0.05m, 0.1m, and 0.2m. The optimal configuration was found to be 0.1m for both parameters, providing a balance between detail preservation and computational efficiency. Leaf sizes smaller than 0.1m did not yield significant accuracy improvements but increased processing times, while larger sizes compromised localization accuracy.

\subsection{Mathematical Formulation of 3D-BBS}
To provide a deeper understanding of the 3D-BBS algorithm, we present the detailed mathematical formulations governing its operations.

\subsubsection{Transformation Matrix}
The transformation matrix $T_{\mathbf{x}}$ encapsulates both rotation and translation, defined as:

\begin{equation*}
T_{\mathbf{x}} = \begin{bmatrix}
R(\alpha, \beta, \gamma) & \mathbf{t} \\
\mathbf{0}^T & 1
\end{bmatrix},
\end{equation*}

where $R(\alpha, \beta, \gamma)$ is the rotation matrix constructed from Euler angles $(\alpha, \beta, \gamma)$, and $\mathbf{t} = [x, y, z]^T$ represents the translation vector. The rotation matrix can be decomposed into sequential rotations about the $x$, $y$, and $z$ axes:

$$R(\alpha, \beta, \gamma) = R_z(\gamma) R_y(\beta) R_x(\alpha)$$

with each individual rotation matrix defined as:

\begin{align}
R_x(\alpha) &= \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos\alpha & -\sin\alpha \\
0 & \sin\alpha & \cos\alpha
\end{bmatrix}, \\
R_y(\beta) &= \begin{bmatrix}
\cos\beta & 0 & \sin\beta \\
0 & 1 & 0 \\
-\sin\beta & 0 & \cos\beta
\end{bmatrix}, \\
R_z(\gamma) &= \begin{bmatrix}
\cos\gamma & -\sin\gamma & 0 \\
\sin\gamma & \cos\gamma & 0 \\
0 & 0 & 1
\end{bmatrix}.
\end{align}

\subsubsection{Voxel Occupancy Function}
The voxel occupancy function $\mathcal{H}_l(\mathbf{v})$ is critical for determining the correspondence between scan points and map voxels. Given a voxel $\mathbf{v} = [v_x, v_y, v_z]^T$, the occupancy function at level $l$ is:

\begin{equation*}
\mathcal{H}_l(\mathbf{v}) = 
\begin{cases}
1 & \text{if voxel } \mathbf{v} \text{ is occupied in map } \mathcal{M}, \\
0 & \text{otherwise}.
\end{cases}
\end{equation*}

This binary occupancy simplifies the score computation, as it directly indicates whether a scan point aligns with an occupied voxel in the map.

\subsubsection{Upper Bound Calculation}
A pivotal component of the BnB algorithm is the computation of upper bounds to facilitate efficient pruning. For a given parent node $c$, the upper bound $\text{score}_{\text{upper}}(c)$ is estimated by aggregating the maximum possible contributions from its child nodes:

$$\text{score}_{\text{upper}}(c) = \sum_{k=1}^{K} \max_{\mathbf{v} \in \mathcal{N}(T_{\mathbf{x}}c \mathbf{s}_k)} \mathcal{H}_l(\mathbf{v})$$,

where $\mathcal{N}(\cdot)$ denotes the set of neighboring voxels around the transformed scan point $T_{\mathbf{x}}c \mathbf{s}_k$. This upper bound ensures that if $\text{score}_{\text{upper}}(c)$ is less than the current best score, the node $c$ and its descendants can be safely pruned.

\subsubsection{Search Space Partitioning}
The hierarchical partitioning of the search space is governed by the maximum hierarchical level $l_{\text{max}}$ and the minimum resolution $r$. At each level $l$, the voxel size is $r_l = 2^l r$, and the search space is divided accordingly. The branching factor increases exponentially with each hierarchical level, necessitating efficient management of the search tree.

To manage the exponential growth, the algorithm employs a combination of translational and rotational branching. This approach ensures that both position and orientation are refined systematically, allowing the algorithm to converge to the optimal pose efficiently.

\subsubsection{Algorithmic Enhancements}
Several algorithmic enhancements are incorporated to optimize the performance of the 3D-BBS algorithm:

\begin{itemize}
    \item \textbf{Sparse Voxel Representation}: Utilizing a sparse hash table for voxel storage significantly reduces memory consumption, especially in large-scale environments with sparse occupancy.
    \item \textbf{Roto-Translational Branching}: By simultaneously refining both translational and rotational components, the algorithm achieves higher localization precision without incurring excessive computational costs.
    \item \textbf{GPU-Accelerated Batched Processing}: Leveraging GPU parallelism for score computations and branching operations accelerates the overall localization process, enabling real-time performance.
    \item \textbf{Batch Size Optimization}: Determining an optimal batch size $b$ is crucial for maximizing GPU utilization while minimizing data transfer overhead. Empirical studies suggest that a batch size of 10,000 nodes strikes an optimal balance.
\end{itemize}

\subsection{Implementation Details}
The 3D-BBS algorithm is implemented in C++ with CUDA extensions to harness the computational power of GPUs. The implementation follows a modular architecture, encapsulating different components such as voxel mapping, BnB search, and GPU processing into distinct modules for maintainability and scalability.

\subsubsection{Voxel Map Construction}
The voxel map is constructed by discretizing the 3D space into voxels of size $r_l = 2^l r$ at each hierarchical level. Occupied voxels are identified based on the presence of LiDAR scan points within their boundaries. The spatial hashing function ensures efficient storage and retrieval of voxel occupancy information.

Mathematically, for each point $\mathbf{m}_n \in \mathcal{M}$, its corresponding voxel at level $l$ is computed as:

$$\mathbf{v}_n^l = \left\lfloor \frac{\mathbf{m}_n}{r_l} \right\rfloor$$

where $\lfloor \cdot \rfloor$ denotes the floor operation applied element-wise. The voxel coordinates $\mathbf{v}_n^l$ are then hashed and stored in the sparse voxel map $\mathcal{H}_l$.

\subsubsection{GPU Acceleration}
The GPU-accelerated batched BnB algorithm leverages CUDA to parallelize the computation of matching scores and the branching process. Key implementation strategies include:

\begin{itemize}
    \item \textbf{Memory Optimization}: Voxel maps are preloaded into GPU memory to minimize data transfer overhead during score computations.
    \item \textbf{Parallel Score Calculation}: Each thread in the GPU handles the score computation for a single node within a batch, utilizing shared memory to store intermediate results and reduce latency.
    \item \textbf{Efficient Branching}: The branching process is parallelized by allowing multiple child nodes to be generated simultaneously, thereby speeding up the exploration of the search space.
\end{itemize}

The CUDA kernels are designed to maximize occupancy and throughput, ensuring that the GPU resources are utilized effectively. Profiling and optimization techniques are employed to identify and eliminate bottlenecks, achieving significant speedups over CPU-based implementations.

\subsection{Mathematical Analysis of 3D-BBS Efficiency}
To evaluate the computational efficiency of the 3D-BBS algorithm, we analyze its time complexity and memory usage in relation to the hierarchical parameters.

\subsubsection{Time Complexity}
The time complexity of the 3D-BBS algorithm is influenced by the number of hierarchical levels $l_{\text{max}}$, the voxel size $r$, and the branching factor at each level. At each hierarchical level $l$, the number of possible pose candidates increases exponentially with both translational and rotational dimensions.

Assuming a uniform branching factor $b_t$ for translations and $b_r$ for rotations, the total number of pose candidates $N_c$ at level $l_{\text{max}}$ is given by:

$$N_c = (b_t \times b_r)^{l_{\text{max}}}$$

Given the hierarchical partitioning, the algorithm achieves a logarithmic reduction in search space through effective pruning based on upper bound scores. Empirical analysis indicates that the batched GPU processing significantly mitigates the exponential growth, enabling real-time localization even in extensive maps.

\subsubsection{Memory Usage}
The memory consumption of the 3D-BBS algorithm is primarily dictated by the voxel map size and the search tree's hierarchical depth. Utilizing a sparse voxel representation reduces memory requirements substantially, as only occupied voxels are stored. The spatial hashing technique further optimizes memory usage by minimizing collisions and ensuring efficient storage.

At each level $l$, the number of occupied voxels $N_v^l$ is proportional to the environmental complexity and the voxel size $r_l$. The total memory required for the voxel map across all levels can be approximated as:

$$M_{\text{total}} = \sum_{l=0}^{l_{\text{max}}} N_v^l \times \text{sizeof}(\mathcal{H}_l)$$

Empirical results demonstrate that the sparse hash table approach scales linearly with the number of occupied voxels, maintaining manageable memory usage even in large-scale environments.
